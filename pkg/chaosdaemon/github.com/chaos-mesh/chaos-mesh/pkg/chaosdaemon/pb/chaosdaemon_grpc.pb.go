// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.5.0
// source: pb/chaosdaemon.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ChaosDaemon_SetTcs_FullMethodName            = "/pb.ChaosDaemon/SetTcs"
	ChaosDaemon_FlushIPSets_FullMethodName       = "/pb.ChaosDaemon/FlushIPSets"
	ChaosDaemon_SetIptablesChains_FullMethodName = "/pb.ChaosDaemon/SetIptablesChains"
	ChaosDaemon_SetTimeOffset_FullMethodName     = "/pb.ChaosDaemon/SetTimeOffset"
	ChaosDaemon_RecoverTimeOffset_FullMethodName = "/pb.ChaosDaemon/RecoverTimeOffset"
	ChaosDaemon_ContainerKill_FullMethodName     = "/pb.ChaosDaemon/ContainerKill"
	ChaosDaemon_ContainerGetPid_FullMethodName   = "/pb.ChaosDaemon/ContainerGetPid"
	ChaosDaemon_ExecStressors_FullMethodName     = "/pb.ChaosDaemon/ExecStressors"
	ChaosDaemon_CancelStressors_FullMethodName   = "/pb.ChaosDaemon/CancelStressors"
	ChaosDaemon_ApplyIOChaos_FullMethodName      = "/pb.ChaosDaemon/ApplyIOChaos"
	ChaosDaemon_ApplyHttpChaos_FullMethodName    = "/pb.ChaosDaemon/ApplyHttpChaos"
	ChaosDaemon_ApplyBlockChaos_FullMethodName   = "/pb.ChaosDaemon/ApplyBlockChaos"
	ChaosDaemon_RecoverBlockChaos_FullMethodName = "/pb.ChaosDaemon/RecoverBlockChaos"
	ChaosDaemon_SetDNSServer_FullMethodName      = "/pb.ChaosDaemon/SetDNSServer"
	ChaosDaemon_InstallJVMRules_FullMethodName   = "/pb.ChaosDaemon/InstallJVMRules"
	ChaosDaemon_UninstallJVMRules_FullMethodName = "/pb.ChaosDaemon/UninstallJVMRules"
)

// ChaosDaemonClient is the client API for ChaosDaemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChaosDaemonClient interface {
	SetTcs(ctx context.Context, in *TcsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	FlushIPSets(ctx context.Context, in *IPSetsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetIptablesChains(ctx context.Context, in *IptablesChainsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RecoverTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ContainerKill(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ContainerGetPid(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*ContainerResponse, error)
	ExecStressors(ctx context.Context, in *ExecStressRequest, opts ...grpc.CallOption) (*ExecStressResponse, error)
	CancelStressors(ctx context.Context, in *CancelStressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ApplyIOChaos(ctx context.Context, in *ApplyIOChaosRequest, opts ...grpc.CallOption) (*ApplyIOChaosResponse, error)
	ApplyHttpChaos(ctx context.Context, in *ApplyHttpChaosRequest, opts ...grpc.CallOption) (*ApplyHttpChaosResponse, error)
	ApplyBlockChaos(ctx context.Context, in *ApplyBlockChaosRequest, opts ...grpc.CallOption) (*ApplyBlockChaosResponse, error)
	RecoverBlockChaos(ctx context.Context, in *RecoverBlockChaosRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetDNSServer(ctx context.Context, in *SetDNSServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	InstallJVMRules(ctx context.Context, in *InstallJVMRulesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UninstallJVMRules(ctx context.Context, in *UninstallJVMRulesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type chaosDaemonClient struct {
	cc grpc.ClientConnInterface
}

func NewChaosDaemonClient(cc grpc.ClientConnInterface) ChaosDaemonClient {
	return &chaosDaemonClient{cc}
}

func (c *chaosDaemonClient) SetTcs(ctx context.Context, in *TcsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_SetTcs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) FlushIPSets(ctx context.Context, in *IPSetsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_FlushIPSets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) SetIptablesChains(ctx context.Context, in *IptablesChainsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_SetIptablesChains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) SetTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_SetTimeOffset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) RecoverTimeOffset(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_RecoverTimeOffset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ContainerKill(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_ContainerKill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ContainerGetPid(ctx context.Context, in *ContainerRequest, opts ...grpc.CallOption) (*ContainerResponse, error) {
	out := new(ContainerResponse)
	err := c.cc.Invoke(ctx, ChaosDaemon_ContainerGetPid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ExecStressors(ctx context.Context, in *ExecStressRequest, opts ...grpc.CallOption) (*ExecStressResponse, error) {
	out := new(ExecStressResponse)
	err := c.cc.Invoke(ctx, ChaosDaemon_ExecStressors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) CancelStressors(ctx context.Context, in *CancelStressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_CancelStressors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ApplyIOChaos(ctx context.Context, in *ApplyIOChaosRequest, opts ...grpc.CallOption) (*ApplyIOChaosResponse, error) {
	out := new(ApplyIOChaosResponse)
	err := c.cc.Invoke(ctx, ChaosDaemon_ApplyIOChaos_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ApplyHttpChaos(ctx context.Context, in *ApplyHttpChaosRequest, opts ...grpc.CallOption) (*ApplyHttpChaosResponse, error) {
	out := new(ApplyHttpChaosResponse)
	err := c.cc.Invoke(ctx, ChaosDaemon_ApplyHttpChaos_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) ApplyBlockChaos(ctx context.Context, in *ApplyBlockChaosRequest, opts ...grpc.CallOption) (*ApplyBlockChaosResponse, error) {
	out := new(ApplyBlockChaosResponse)
	err := c.cc.Invoke(ctx, ChaosDaemon_ApplyBlockChaos_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) RecoverBlockChaos(ctx context.Context, in *RecoverBlockChaosRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_RecoverBlockChaos_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) SetDNSServer(ctx context.Context, in *SetDNSServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_SetDNSServer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) InstallJVMRules(ctx context.Context, in *InstallJVMRulesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_InstallJVMRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chaosDaemonClient) UninstallJVMRules(ctx context.Context, in *UninstallJVMRulesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChaosDaemon_UninstallJVMRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChaosDaemonServer is the server API for ChaosDaemon service.
// All implementations must embed UnimplementedChaosDaemonServer
// for forward compatibility
type ChaosDaemonServer interface {
	SetTcs(context.Context, *TcsRequest) (*emptypb.Empty, error)
	FlushIPSets(context.Context, *IPSetsRequest) (*emptypb.Empty, error)
	SetIptablesChains(context.Context, *IptablesChainsRequest) (*emptypb.Empty, error)
	SetTimeOffset(context.Context, *TimeRequest) (*emptypb.Empty, error)
	RecoverTimeOffset(context.Context, *TimeRequest) (*emptypb.Empty, error)
	ContainerKill(context.Context, *ContainerRequest) (*emptypb.Empty, error)
	ContainerGetPid(context.Context, *ContainerRequest) (*ContainerResponse, error)
	ExecStressors(context.Context, *ExecStressRequest) (*ExecStressResponse, error)
	CancelStressors(context.Context, *CancelStressRequest) (*emptypb.Empty, error)
	ApplyIOChaos(context.Context, *ApplyIOChaosRequest) (*ApplyIOChaosResponse, error)
	ApplyHttpChaos(context.Context, *ApplyHttpChaosRequest) (*ApplyHttpChaosResponse, error)
	ApplyBlockChaos(context.Context, *ApplyBlockChaosRequest) (*ApplyBlockChaosResponse, error)
	RecoverBlockChaos(context.Context, *RecoverBlockChaosRequest) (*emptypb.Empty, error)
	SetDNSServer(context.Context, *SetDNSServerRequest) (*emptypb.Empty, error)
	InstallJVMRules(context.Context, *InstallJVMRulesRequest) (*emptypb.Empty, error)
	UninstallJVMRules(context.Context, *UninstallJVMRulesRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedChaosDaemonServer()
}

// UnimplementedChaosDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedChaosDaemonServer struct {
}

func (UnimplementedChaosDaemonServer) SetTcs(context.Context, *TcsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTcs not implemented")
}
func (UnimplementedChaosDaemonServer) FlushIPSets(context.Context, *IPSetsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushIPSets not implemented")
}
func (UnimplementedChaosDaemonServer) SetIptablesChains(context.Context, *IptablesChainsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIptablesChains not implemented")
}
func (UnimplementedChaosDaemonServer) SetTimeOffset(context.Context, *TimeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeOffset not implemented")
}
func (UnimplementedChaosDaemonServer) RecoverTimeOffset(context.Context, *TimeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverTimeOffset not implemented")
}
func (UnimplementedChaosDaemonServer) ContainerKill(context.Context, *ContainerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerKill not implemented")
}
func (UnimplementedChaosDaemonServer) ContainerGetPid(context.Context, *ContainerRequest) (*ContainerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerGetPid not implemented")
}
func (UnimplementedChaosDaemonServer) ExecStressors(context.Context, *ExecStressRequest) (*ExecStressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecStressors not implemented")
}
func (UnimplementedChaosDaemonServer) CancelStressors(context.Context, *CancelStressRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelStressors not implemented")
}
func (UnimplementedChaosDaemonServer) ApplyIOChaos(context.Context, *ApplyIOChaosRequest) (*ApplyIOChaosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyIOChaos not implemented")
}
func (UnimplementedChaosDaemonServer) ApplyHttpChaos(context.Context, *ApplyHttpChaosRequest) (*ApplyHttpChaosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyHttpChaos not implemented")
}
func (UnimplementedChaosDaemonServer) ApplyBlockChaos(context.Context, *ApplyBlockChaosRequest) (*ApplyBlockChaosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyBlockChaos not implemented")
}
func (UnimplementedChaosDaemonServer) RecoverBlockChaos(context.Context, *RecoverBlockChaosRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverBlockChaos not implemented")
}
func (UnimplementedChaosDaemonServer) SetDNSServer(context.Context, *SetDNSServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDNSServer not implemented")
}
func (UnimplementedChaosDaemonServer) InstallJVMRules(context.Context, *InstallJVMRulesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallJVMRules not implemented")
}
func (UnimplementedChaosDaemonServer) UninstallJVMRules(context.Context, *UninstallJVMRulesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UninstallJVMRules not implemented")
}
func (UnimplementedChaosDaemonServer) mustEmbedUnimplementedChaosDaemonServer() {}

// UnsafeChaosDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChaosDaemonServer will
// result in compilation errors.
type UnsafeChaosDaemonServer interface {
	mustEmbedUnimplementedChaosDaemonServer()
}

func RegisterChaosDaemonServer(s grpc.ServiceRegistrar, srv ChaosDaemonServer) {
	s.RegisterService(&ChaosDaemon_ServiceDesc, srv)
}

func _ChaosDaemon_SetTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_SetTcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetTcs(ctx, req.(*TcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_FlushIPSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).FlushIPSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_FlushIPSets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).FlushIPSets(ctx, req.(*IPSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_SetIptablesChains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IptablesChainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetIptablesChains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_SetIptablesChains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetIptablesChains(ctx, req.(*IptablesChainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_SetTimeOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetTimeOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_SetTimeOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetTimeOffset(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_RecoverTimeOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).RecoverTimeOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_RecoverTimeOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).RecoverTimeOffset(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ContainerKill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ContainerKill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ContainerKill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ContainerKill(ctx, req.(*ContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ContainerGetPid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ContainerGetPid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ContainerGetPid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ContainerGetPid(ctx, req.(*ContainerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ExecStressors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecStressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ExecStressors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ExecStressors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ExecStressors(ctx, req.(*ExecStressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_CancelStressors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).CancelStressors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_CancelStressors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).CancelStressors(ctx, req.(*CancelStressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ApplyIOChaos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyIOChaosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ApplyIOChaos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ApplyIOChaos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ApplyIOChaos(ctx, req.(*ApplyIOChaosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ApplyHttpChaos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyHttpChaosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ApplyHttpChaos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ApplyHttpChaos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ApplyHttpChaos(ctx, req.(*ApplyHttpChaosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_ApplyBlockChaos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyBlockChaosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).ApplyBlockChaos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_ApplyBlockChaos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).ApplyBlockChaos(ctx, req.(*ApplyBlockChaosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_RecoverBlockChaos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoverBlockChaosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).RecoverBlockChaos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_RecoverBlockChaos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).RecoverBlockChaos(ctx, req.(*RecoverBlockChaosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_SetDNSServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDNSServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).SetDNSServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_SetDNSServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).SetDNSServer(ctx, req.(*SetDNSServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_InstallJVMRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallJVMRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).InstallJVMRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_InstallJVMRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).InstallJVMRules(ctx, req.(*InstallJVMRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChaosDaemon_UninstallJVMRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UninstallJVMRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChaosDaemonServer).UninstallJVMRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChaosDaemon_UninstallJVMRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChaosDaemonServer).UninstallJVMRules(ctx, req.(*UninstallJVMRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChaosDaemon_ServiceDesc is the grpc.ServiceDesc for ChaosDaemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChaosDaemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ChaosDaemon",
	HandlerType: (*ChaosDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetTcs",
			Handler:    _ChaosDaemon_SetTcs_Handler,
		},
		{
			MethodName: "FlushIPSets",
			Handler:    _ChaosDaemon_FlushIPSets_Handler,
		},
		{
			MethodName: "SetIptablesChains",
			Handler:    _ChaosDaemon_SetIptablesChains_Handler,
		},
		{
			MethodName: "SetTimeOffset",
			Handler:    _ChaosDaemon_SetTimeOffset_Handler,
		},
		{
			MethodName: "RecoverTimeOffset",
			Handler:    _ChaosDaemon_RecoverTimeOffset_Handler,
		},
		{
			MethodName: "ContainerKill",
			Handler:    _ChaosDaemon_ContainerKill_Handler,
		},
		{
			MethodName: "ContainerGetPid",
			Handler:    _ChaosDaemon_ContainerGetPid_Handler,
		},
		{
			MethodName: "ExecStressors",
			Handler:    _ChaosDaemon_ExecStressors_Handler,
		},
		{
			MethodName: "CancelStressors",
			Handler:    _ChaosDaemon_CancelStressors_Handler,
		},
		{
			MethodName: "ApplyIOChaos",
			Handler:    _ChaosDaemon_ApplyIOChaos_Handler,
		},
		{
			MethodName: "ApplyHttpChaos",
			Handler:    _ChaosDaemon_ApplyHttpChaos_Handler,
		},
		{
			MethodName: "ApplyBlockChaos",
			Handler:    _ChaosDaemon_ApplyBlockChaos_Handler,
		},
		{
			MethodName: "RecoverBlockChaos",
			Handler:    _ChaosDaemon_RecoverBlockChaos_Handler,
		},
		{
			MethodName: "SetDNSServer",
			Handler:    _ChaosDaemon_SetDNSServer_Handler,
		},
		{
			MethodName: "InstallJVMRules",
			Handler:    _ChaosDaemon_InstallJVMRules_Handler,
		},
		{
			MethodName: "UninstallJVMRules",
			Handler:    _ChaosDaemon_UninstallJVMRules_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/chaosdaemon.proto",
}
